/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package sell.fulfillment.definitions

import cats.syntax.either._
import io.circe._
import io.circe.syntax._
import cats.implicits._
import _root_.sell.fulfillment.Implicits._
case class Order(buyer: Option[Buyer] = None, buyerCheckoutNotes: Option[String] = None, cancelStatus: Option[CancelStatus] = None, creationDate: Option[String] = None, ebayCollectAndRemitTax: Option[Boolean] = None, fulfillmentHrefs: Option[Vector[String]] = None, fulfillmentStartInstructions: Option[_root_.scala.Vector[FulfillmentStartInstruction]] = None, lastModifiedDate: Option[String] = None, legacyOrderId: Option[String] = None, lineItems: Option[_root_.scala.Vector[LineItem]] = None, orderFulfillmentStatus: Option[String] = None, orderId: Option[String] = None, orderPaymentStatus: Option[String] = None, paymentSummary: Option[PaymentSummary] = None, pricingSummary: Option[PricingSummary] = None, program: Option[Program] = None, salesRecordReference: Option[String] = None, sellerId: Option[String] = None, totalFeeBasisAmount: Option[Amount] = None, totalMarketplaceFee: Option[Amount] = None)
object Order {
  implicit val encodeOrder: _root_.io.circe.Encoder.AsObject[Order] = {
    val readOnlyKeys = _root_.scala.Predef.Set[_root_.scala.Predef.String]()
    _root_.io.circe.Encoder.AsObject.instance[Order](a => _root_.io.circe.JsonObject.fromIterable(_root_.scala.Vector(("buyer", a.buyer.asJson), ("buyerCheckoutNotes", a.buyerCheckoutNotes.asJson), ("cancelStatus", a.cancelStatus.asJson), ("creationDate", a.creationDate.asJson), ("ebayCollectAndRemitTax", a.ebayCollectAndRemitTax.asJson), ("fulfillmentHrefs", a.fulfillmentHrefs.asJson), ("fulfillmentStartInstructions", a.fulfillmentStartInstructions.asJson), ("lastModifiedDate", a.lastModifiedDate.asJson), ("legacyOrderId", a.legacyOrderId.asJson), ("lineItems", a.lineItems.asJson), ("orderFulfillmentStatus", a.orderFulfillmentStatus.asJson), ("orderId", a.orderId.asJson), ("orderPaymentStatus", a.orderPaymentStatus.asJson), ("paymentSummary", a.paymentSummary.asJson), ("pricingSummary", a.pricingSummary.asJson), ("program", a.program.asJson), ("salesRecordReference", a.salesRecordReference.asJson), ("sellerId", a.sellerId.asJson), ("totalFeeBasisAmount", a.totalFeeBasisAmount.asJson), ("totalMarketplaceFee", a.totalMarketplaceFee.asJson)))).mapJsonObject(_.filterKeys(key => !(readOnlyKeys contains key)))
  }
  implicit val decodeOrder: _root_.io.circe.Decoder[Order] = new _root_.io.circe.Decoder[Order] { final def apply(c: _root_.io.circe.HCursor): _root_.io.circe.Decoder.Result[Order] = for (v0 <- c.downField("buyer").as[Option[Buyer]]; v1 <- c.downField("buyerCheckoutNotes").as[Option[String]]; v2 <- c.downField("cancelStatus").as[Option[CancelStatus]]; v3 <- c.downField("creationDate").as[Option[String]]; v4 <- c.downField("ebayCollectAndRemitTax").as[Option[Boolean]]; v5 <- c.downField("fulfillmentHrefs").as[Option[Vector[String]]]; v6 <- c.downField("fulfillmentStartInstructions").as[Option[_root_.scala.Vector[FulfillmentStartInstruction]]]; v7 <- c.downField("lastModifiedDate").as[Option[String]]; v8 <- c.downField("legacyOrderId").as[Option[String]]; v9 <- c.downField("lineItems").as[Option[_root_.scala.Vector[LineItem]]]; v10 <- c.downField("orderFulfillmentStatus").as[Option[String]]; v11 <- c.downField("orderId").as[Option[String]]; v12 <- c.downField("orderPaymentStatus").as[Option[String]]; v13 <- c.downField("paymentSummary").as[Option[PaymentSummary]]; v14 <- c.downField("pricingSummary").as[Option[PricingSummary]]; v15 <- c.downField("program").as[Option[Program]]; v16 <- c.downField("salesRecordReference").as[Option[String]]; v17 <- c.downField("sellerId").as[Option[String]]; v18 <- c.downField("totalFeeBasisAmount").as[Option[Amount]]; v19 <- c.downField("totalMarketplaceFee").as[Option[Amount]]) yield Order(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) }
}