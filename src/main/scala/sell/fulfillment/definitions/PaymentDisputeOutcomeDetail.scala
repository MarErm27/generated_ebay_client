/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package sell.fulfillment.definitions

import cats.syntax.either._
import io.circe._
import io.circe.syntax._
import cats.implicits._
import _root_.sell.fulfillment.Implicits._
case class PaymentDisputeOutcomeDetail(fees: Option[SimpleAmount] = None, protectedAmount: Option[SimpleAmount] = None, protectionStatus: Option[String] = None, reasonForClosure: Option[String] = None, recoupAmount: Option[SimpleAmount] = None, totalFeeCredit: Option[SimpleAmount] = None)
object PaymentDisputeOutcomeDetail {
  implicit val encodePaymentDisputeOutcomeDetail: _root_.io.circe.Encoder.AsObject[PaymentDisputeOutcomeDetail] = {
    val readOnlyKeys = _root_.scala.Predef.Set[_root_.scala.Predef.String]()
    _root_.io.circe.Encoder.AsObject.instance[PaymentDisputeOutcomeDetail](a => _root_.io.circe.JsonObject.fromIterable(_root_.scala.Vector(("fees", a.fees.asJson), ("protectedAmount", a.protectedAmount.asJson), ("protectionStatus", a.protectionStatus.asJson), ("reasonForClosure", a.reasonForClosure.asJson), ("recoupAmount", a.recoupAmount.asJson), ("totalFeeCredit", a.totalFeeCredit.asJson)))).mapJsonObject(_.filterKeys(key => !(readOnlyKeys contains key)))
  }
  implicit val decodePaymentDisputeOutcomeDetail: _root_.io.circe.Decoder[PaymentDisputeOutcomeDetail] = new _root_.io.circe.Decoder[PaymentDisputeOutcomeDetail] { final def apply(c: _root_.io.circe.HCursor): _root_.io.circe.Decoder.Result[PaymentDisputeOutcomeDetail] = for (v0 <- c.downField("fees").as[Option[SimpleAmount]]; v1 <- c.downField("protectedAmount").as[Option[SimpleAmount]]; v2 <- c.downField("protectionStatus").as[Option[String]]; v3 <- c.downField("reasonForClosure").as[Option[String]]; v4 <- c.downField("recoupAmount").as[Option[SimpleAmount]]; v5 <- c.downField("totalFeeCredit").as[Option[SimpleAmount]]) yield PaymentDisputeOutcomeDetail(v0, v1, v2, v3, v4, v5) }
}