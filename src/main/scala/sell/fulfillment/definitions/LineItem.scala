/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package sell.fulfillment.definitions

import cats.syntax.either._
import io.circe._
import io.circe.syntax._
import cats.implicits._
import _root_.sell.fulfillment.Implicits._
case class LineItem(appliedPromotions: Option[_root_.scala.Vector[AppliedPromotion]] = None, deliveryCost: Option[DeliveryCost] = None, discountedLineItemCost: Option[Amount] = None, ebayCollectAndRemitTaxes: Option[_root_.scala.Vector[EbayCollectAndRemitTax]] = None, giftDetails: Option[GiftDetails] = None, itemLocation: Option[ItemLocation] = None, legacyItemId: Option[String] = None, legacyVariationId: Option[String] = None, lineItemCost: Option[Amount] = None, lineItemFulfillmentInstructions: Option[LineItemFulfillmentInstructions] = None, lineItemFulfillmentStatus: Option[String] = None, lineItemId: Option[String] = None, listingMarketplaceId: Option[String] = None, properties: Option[LineItemProperties] = None, purchaseMarketplaceId: Option[String] = None, quantity: Option[Int] = None, refunds: Option[_root_.scala.Vector[LineItemRefund]] = None, sku: Option[String] = None, soldFormat: Option[String] = None, taxes: Option[_root_.scala.Vector[Tax]] = None, title: Option[String] = None, total: Option[Amount] = None)
object LineItem {
  implicit val encodeLineItem: _root_.io.circe.Encoder.AsObject[LineItem] = {
    val readOnlyKeys = _root_.scala.Predef.Set[_root_.scala.Predef.String]()
    _root_.io.circe.Encoder.AsObject.instance[LineItem](a => _root_.io.circe.JsonObject.fromIterable(_root_.scala.Vector(("appliedPromotions", a.appliedPromotions.asJson), ("deliveryCost", a.deliveryCost.asJson), ("discountedLineItemCost", a.discountedLineItemCost.asJson), ("ebayCollectAndRemitTaxes", a.ebayCollectAndRemitTaxes.asJson), ("giftDetails", a.giftDetails.asJson), ("itemLocation", a.itemLocation.asJson), ("legacyItemId", a.legacyItemId.asJson), ("legacyVariationId", a.legacyVariationId.asJson), ("lineItemCost", a.lineItemCost.asJson), ("lineItemFulfillmentInstructions", a.lineItemFulfillmentInstructions.asJson), ("lineItemFulfillmentStatus", a.lineItemFulfillmentStatus.asJson), ("lineItemId", a.lineItemId.asJson), ("listingMarketplaceId", a.listingMarketplaceId.asJson), ("properties", a.properties.asJson), ("purchaseMarketplaceId", a.purchaseMarketplaceId.asJson), ("quantity", a.quantity.asJson), ("refunds", a.refunds.asJson), ("sku", a.sku.asJson), ("soldFormat", a.soldFormat.asJson), ("taxes", a.taxes.asJson), ("title", a.title.asJson), ("total", a.total.asJson)))).mapJsonObject(_.filterKeys(key => !(readOnlyKeys contains key)))
  }
  implicit val decodeLineItem: _root_.io.circe.Decoder[LineItem] = new _root_.io.circe.Decoder[LineItem] { final def apply(c: _root_.io.circe.HCursor): _root_.io.circe.Decoder.Result[LineItem] = for (v0 <- c.downField("appliedPromotions").as[Option[_root_.scala.Vector[AppliedPromotion]]]; v1 <- c.downField("deliveryCost").as[Option[DeliveryCost]]; v2 <- c.downField("discountedLineItemCost").as[Option[Amount]]; v3 <- c.downField("ebayCollectAndRemitTaxes").as[Option[_root_.scala.Vector[EbayCollectAndRemitTax]]]; v4 <- c.downField("giftDetails").as[Option[GiftDetails]]; v5 <- c.downField("itemLocation").as[Option[ItemLocation]]; v6 <- c.downField("legacyItemId").as[Option[String]]; v7 <- c.downField("legacyVariationId").as[Option[String]]; v8 <- c.downField("lineItemCost").as[Option[Amount]]; v9 <- c.downField("lineItemFulfillmentInstructions").as[Option[LineItemFulfillmentInstructions]]; v10 <- c.downField("lineItemFulfillmentStatus").as[Option[String]]; v11 <- c.downField("lineItemId").as[Option[String]]; v12 <- c.downField("listingMarketplaceId").as[Option[String]]; v13 <- c.downField("properties").as[Option[LineItemProperties]]; v14 <- c.downField("purchaseMarketplaceId").as[Option[String]]; v15 <- c.downField("quantity").as[Option[Int]]; v16 <- c.downField("refunds").as[Option[_root_.scala.Vector[LineItemRefund]]]; v17 <- c.downField("sku").as[Option[String]]; v18 <- c.downField("soldFormat").as[Option[String]]; v19 <- c.downField("taxes").as[Option[_root_.scala.Vector[Tax]]]; v20 <- c.downField("title").as[Option[String]]; v21 <- c.downField("total").as[Option[Amount]]) yield LineItem(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) }
}