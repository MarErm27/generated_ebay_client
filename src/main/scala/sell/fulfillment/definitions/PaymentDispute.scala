/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package sell.fulfillment.definitions

import cats.syntax.either._
import io.circe._
import io.circe.syntax._
import cats.implicits._
import _root_.sell.fulfillment.Implicits._
case class PaymentDispute(amount: Option[SimpleAmount] = None, availableChoices: Option[Vector[String]] = None, buyerProvided: Option[InfoFromBuyer] = None, buyerUsername: Option[String] = None, closedDate: Option[String] = None, evidence: Option[_root_.scala.Vector[DisputeEvidence]] = None, evidenceRequests: Option[_root_.scala.Vector[EvidenceRequest]] = None, lineItems: Option[_root_.scala.Vector[OrderLineItems]] = None, monetaryTransactions: Option[_root_.scala.Vector[MonetaryTransaction]] = None, openDate: Option[String] = None, orderId: Option[String] = None, paymentDisputeId: Option[String] = None, paymentDisputeStatus: Option[String] = None, reason: Option[String] = None, resolution: Option[PaymentDisputeOutcomeDetail] = None, respondByDate: Option[String] = None, returnAddress: Option[ReturnAddress] = None, revision: Option[Int] = None, sellerResponse: Option[String] = None)
object PaymentDispute {
  implicit val encodePaymentDispute: _root_.io.circe.Encoder.AsObject[PaymentDispute] = {
    val readOnlyKeys = _root_.scala.Predef.Set[_root_.scala.Predef.String]()
    _root_.io.circe.Encoder.AsObject.instance[PaymentDispute](a => _root_.io.circe.JsonObject.fromIterable(_root_.scala.Vector(("amount", a.amount.asJson), ("availableChoices", a.availableChoices.asJson), ("buyerProvided", a.buyerProvided.asJson), ("buyerUsername", a.buyerUsername.asJson), ("closedDate", a.closedDate.asJson), ("evidence", a.evidence.asJson), ("evidenceRequests", a.evidenceRequests.asJson), ("lineItems", a.lineItems.asJson), ("monetaryTransactions", a.monetaryTransactions.asJson), ("openDate", a.openDate.asJson), ("orderId", a.orderId.asJson), ("paymentDisputeId", a.paymentDisputeId.asJson), ("paymentDisputeStatus", a.paymentDisputeStatus.asJson), ("reason", a.reason.asJson), ("resolution", a.resolution.asJson), ("respondByDate", a.respondByDate.asJson), ("returnAddress", a.returnAddress.asJson), ("revision", a.revision.asJson), ("sellerResponse", a.sellerResponse.asJson)))).mapJsonObject(_.filterKeys(key => !(readOnlyKeys contains key)))
  }
  implicit val decodePaymentDispute: _root_.io.circe.Decoder[PaymentDispute] = new _root_.io.circe.Decoder[PaymentDispute] { final def apply(c: _root_.io.circe.HCursor): _root_.io.circe.Decoder.Result[PaymentDispute] = for (v0 <- c.downField("amount").as[Option[SimpleAmount]]; v1 <- c.downField("availableChoices").as[Option[Vector[String]]]; v2 <- c.downField("buyerProvided").as[Option[InfoFromBuyer]]; v3 <- c.downField("buyerUsername").as[Option[String]]; v4 <- c.downField("closedDate").as[Option[String]]; v5 <- c.downField("evidence").as[Option[_root_.scala.Vector[DisputeEvidence]]]; v6 <- c.downField("evidenceRequests").as[Option[_root_.scala.Vector[EvidenceRequest]]]; v7 <- c.downField("lineItems").as[Option[_root_.scala.Vector[OrderLineItems]]]; v8 <- c.downField("monetaryTransactions").as[Option[_root_.scala.Vector[MonetaryTransaction]]]; v9 <- c.downField("openDate").as[Option[String]]; v10 <- c.downField("orderId").as[Option[String]]; v11 <- c.downField("paymentDisputeId").as[Option[String]]; v12 <- c.downField("paymentDisputeStatus").as[Option[String]]; v13 <- c.downField("reason").as[Option[String]]; v14 <- c.downField("resolution").as[Option[PaymentDisputeOutcomeDetail]]; v15 <- c.downField("respondByDate").as[Option[String]]; v16 <- c.downField("returnAddress").as[Option[ReturnAddress]]; v17 <- c.downField("revision").as[Option[Int]]; v18 <- c.downField("sellerResponse").as[Option[String]]) yield PaymentDispute(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) }
}