/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package sell.fulfillment

import _root_.sell.fulfillment.Implicits._
import _root_.sell.fulfillment.AkkaHttpImplicits._
import _root_.sell.fulfillment.definitions._
import akka.http.scaladsl.model._
import akka.http.scaladsl.model.headers.RawHeader
import akka.http.scaladsl.unmarshalling.{ Unmarshal, Unmarshaller, FromEntityUnmarshaller, FromRequestUnmarshaller, FromStringUnmarshaller }
import akka.http.scaladsl.marshalling.{ Marshal, Marshaller, Marshalling, ToEntityMarshaller, ToResponseMarshaller }
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.server.{ Directive, Directive0, Directive1, ExceptionHandler, MalformedFormFieldRejection, MalformedHeaderRejection, MissingFormFieldRejection, MalformedRequestContentRejection, Rejection, RejectionError, Route }
import akka.http.scaladsl.util.FastFuture
import akka.stream.{ IOResult, Materializer }
import akka.stream.scaladsl.{ FileIO, Keep, Sink, Source }
import akka.util.ByteString
import cats.{ Functor, Id }
import cats.data.EitherT
import cats.implicits._
import scala.concurrent.{ ExecutionContext, Future }
import scala.language.higherKinds
import scala.language.implicitConversions
import java.io.File
import java.security.MessageDigest
import java.util.concurrent.atomic.AtomicReference
import scala.util.{ Failure, Success }
import io.circe.Decoder
object Client {
  def apply(host: String = "https://api.ebay.com")(implicit httpClient: HttpRequest => Future[HttpResponse], ec: ExecutionContext, mat: Materializer): Client = new Client(host = host)(httpClient = httpClient, ec = ec, mat = mat)
  def httpClient(httpClient: HttpRequest => Future[HttpResponse], host: String = "https://api.ebay.com")(implicit ec: ExecutionContext, mat: Materializer): Client = new Client(host = host)(httpClient = httpClient, ec = ec, mat = mat)
}
class Client(host: String = "https://api.ebay.com")(implicit httpClient: HttpRequest => Future[HttpResponse], ec: ExecutionContext, mat: Materializer) {
  val basePath: String = "/sell/fulfillment/v1"
  private[this] def makeRequest[T: ToEntityMarshaller](method: HttpMethod, uri: Uri, headers: scala.collection.immutable.Seq[HttpHeader], entity: T, protocol: HttpProtocol): EitherT[Future, Either[Throwable, HttpResponse], HttpRequest] = {
    EitherT(Marshal(entity).to[RequestEntity].map[Either[Either[Throwable, HttpResponse], HttpRequest]] {
      entity => Right(HttpRequest(method = method, uri = uri, headers = headers, entity = entity, protocol = protocol))
    }.recover({
      case t =>
        Left(Left(t))
    }))
  }
  val getOrdersOKDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[_root_.sell.fulfillment.definitions.OrderSearchPagedCollection].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  val getOrderOKDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[_root_.sell.fulfillment.definitions.Order].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  val createShippingFulfillmentCreatedDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[io.circe.Json].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  val getShippingFulfillmentsOKDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[_root_.sell.fulfillment.definitions.ShippingFulfillmentPagedCollection].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  val getShippingFulfillmentOKDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[_root_.sell.fulfillment.definitions.ShippingFulfillment].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  val issueRefundOKDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[_root_.sell.fulfillment.definitions.Refund].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  val getPaymentDisputeOKDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[_root_.sell.fulfillment.definitions.PaymentDispute].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  val getActivitiesOKDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[_root_.sell.fulfillment.definitions.PaymentDisputeActivityHistory].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  val addEvidenceOKDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[_root_.sell.fulfillment.definitions.AddEvidencePaymentDisputeResponse].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  val fetchEvidenceContentOKDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[Vector[String]].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  val uploadEvidenceFileOKDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[_root_.sell.fulfillment.definitions.FileEvidence].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  val getPaymentDisputeSummariesOKDecoder = {
    structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[_root_.sell.fulfillment.definitions.DisputeSummaryResponse].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
  }
  def getOrders(fieldGroups: Option[String] = None, filter: Option[String] = None, limit: Option[String] = None, offset: Option[String] = None, orderIds: Option[String] = None, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], GetOrdersResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.GET, host + basePath + "/order" + "?" + Formatter.addArg("fieldGroups", fieldGroups) + Formatter.addArg("filter", filter) + Formatter.addArg("limit", limit) + Formatter.addArg("offset", offset) + Formatter.addArg("orderIds", orderIds), allHeaders, HttpEntity.Empty, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.OK =>
        Unmarshal(resp.entity).to[_root_.sell.fulfillment.definitions.OrderSearchPagedCollection](getOrdersOKDecoder, implicitly, implicitly).map(x => Right(GetOrdersResponse.OK(x)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(GetOrdersResponse.BadRequest))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(GetOrdersResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def getOrder(orderId: String, fieldGroups: Option[String] = None, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], GetOrderResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.GET, host + basePath + "/order/" + Formatter.addPath(orderId) + "?" + Formatter.addArg("fieldGroups", fieldGroups), allHeaders, HttpEntity.Empty, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.OK =>
        Unmarshal(resp.entity).to[_root_.sell.fulfillment.definitions.Order](getOrderOKDecoder, implicitly, implicitly).map(x => Right(GetOrderResponse.OK(x)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(GetOrderResponse.BadRequest))
      case StatusCodes.NotFound =>
        resp.discardEntityBytes().future.map(_ => Right(GetOrderResponse.NotFound))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(GetOrderResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def createShippingFulfillment(orderId: String, body: _root_.sell.fulfillment.definitions.ShippingFulfillmentDetails, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], CreateShippingFulfillmentResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.POST, host + basePath + "/order/" + Formatter.addPath(orderId) + "/shipping_fulfillment", allHeaders, body, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.Created =>
        val locationHeader = resp.headers.find(_.is("location")).map(_.value())
        Unmarshal(resp.entity).to[io.circe.Json](createShippingFulfillmentCreatedDecoder, implicitly, implicitly).map(x => Right(CreateShippingFulfillmentResponse.Created(x, locationHeader)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(CreateShippingFulfillmentResponse.BadRequest))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(CreateShippingFulfillmentResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def getShippingFulfillments(orderId: String, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], GetShippingFulfillmentsResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.GET, host + basePath + "/order/" + Formatter.addPath(orderId) + "/shipping_fulfillment", allHeaders, HttpEntity.Empty, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.OK =>
        Unmarshal(resp.entity).to[_root_.sell.fulfillment.definitions.ShippingFulfillmentPagedCollection](getShippingFulfillmentsOKDecoder, implicitly, implicitly).map(x => Right(GetShippingFulfillmentsResponse.OK(x)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(GetShippingFulfillmentsResponse.BadRequest))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(GetShippingFulfillmentsResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def getShippingFulfillment(fulfillmentId: String, orderId: String, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], GetShippingFulfillmentResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.GET, host + basePath + "/order/" + Formatter.addPath(orderId) + "/shipping_fulfillment/" + Formatter.addPath(fulfillmentId), allHeaders, HttpEntity.Empty, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.OK =>
        Unmarshal(resp.entity).to[_root_.sell.fulfillment.definitions.ShippingFulfillment](getShippingFulfillmentOKDecoder, implicitly, implicitly).map(x => Right(GetShippingFulfillmentResponse.OK(x)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(GetShippingFulfillmentResponse.BadRequest))
      case StatusCodes.NotFound =>
        resp.discardEntityBytes().future.map(_ => Right(GetShippingFulfillmentResponse.NotFound))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(GetShippingFulfillmentResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def issueRefund(orderId: String, body: Option[_root_.sell.fulfillment.definitions.IssueRefundRequest] = None, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], IssueRefundResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.POST, host + basePath + "/order/" + Formatter.addPath(orderId) + "/issue_refund", allHeaders, body, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.OK =>
        Unmarshal(resp.entity).to[_root_.sell.fulfillment.definitions.Refund](issueRefundOKDecoder, implicitly, implicitly).map(x => Right(IssueRefundResponse.OK(x)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(IssueRefundResponse.BadRequest))
      case StatusCodes.Forbidden =>
        resp.discardEntityBytes().future.map(_ => Right(IssueRefundResponse.Forbidden))
      case StatusCodes.NotFound =>
        resp.discardEntityBytes().future.map(_ => Right(IssueRefundResponse.NotFound))
      case StatusCodes.Conflict =>
        resp.discardEntityBytes().future.map(_ => Right(IssueRefundResponse.Conflict))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(IssueRefundResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def getPaymentDispute(paymentDisputeId: String, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], GetPaymentDisputeResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.GET, host + basePath + "/payment_dispute/" + Formatter.addPath(paymentDisputeId), allHeaders, HttpEntity.Empty, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.OK =>
        Unmarshal(resp.entity).to[_root_.sell.fulfillment.definitions.PaymentDispute](getPaymentDisputeOKDecoder, implicitly, implicitly).map(x => Right(GetPaymentDisputeResponse.OK(x)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(GetPaymentDisputeResponse.BadRequest))
      case StatusCodes.NotFound =>
        resp.discardEntityBytes().future.map(_ => Right(GetPaymentDisputeResponse.NotFound))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(GetPaymentDisputeResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def acceptPaymentDispute(paymentDisputeId: String, body: Option[_root_.sell.fulfillment.definitions.AcceptPaymentDisputeRequest] = None, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], AcceptPaymentDisputeResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.POST, host + basePath + "/payment_dispute/" + Formatter.addPath(paymentDisputeId) + "/accept", allHeaders, body, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.NoContent =>
        resp.discardEntityBytes().future.map(_ => Right(AcceptPaymentDisputeResponse.NoContent))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(AcceptPaymentDisputeResponse.BadRequest))
      case StatusCodes.NotFound =>
        resp.discardEntityBytes().future.map(_ => Right(AcceptPaymentDisputeResponse.NotFound))
      case StatusCodes.Conflict =>
        resp.discardEntityBytes().future.map(_ => Right(AcceptPaymentDisputeResponse.Conflict))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(AcceptPaymentDisputeResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def getActivities(paymentDisputeId: String, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], GetActivitiesResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.GET, host + basePath + "/payment_dispute/" + Formatter.addPath(paymentDisputeId) + "/activity", allHeaders, HttpEntity.Empty, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.OK =>
        Unmarshal(resp.entity).to[_root_.sell.fulfillment.definitions.PaymentDisputeActivityHistory](getActivitiesOKDecoder, implicitly, implicitly).map(x => Right(GetActivitiesResponse.OK(x)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(GetActivitiesResponse.BadRequest))
      case StatusCodes.NotFound =>
        resp.discardEntityBytes().future.map(_ => Right(GetActivitiesResponse.NotFound))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(GetActivitiesResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def addEvidence(paymentDisputeId: String, body: Option[_root_.sell.fulfillment.definitions.AddEvidencePaymentDisputeRequest] = None, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], AddEvidenceResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.POST, host + basePath + "/payment_dispute/" + Formatter.addPath(paymentDisputeId) + "/add_evidence", allHeaders, body, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.OK =>
        Unmarshal(resp.entity).to[_root_.sell.fulfillment.definitions.AddEvidencePaymentDisputeResponse](addEvidenceOKDecoder, implicitly, implicitly).map(x => Right(AddEvidenceResponse.OK(x)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(AddEvidenceResponse.BadRequest))
      case StatusCodes.NotFound =>
        resp.discardEntityBytes().future.map(_ => Right(AddEvidenceResponse.NotFound))
      case StatusCodes.Conflict =>
        resp.discardEntityBytes().future.map(_ => Right(AddEvidenceResponse.Conflict))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(AddEvidenceResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def contestPaymentDispute(paymentDisputeId: String, body: Option[_root_.sell.fulfillment.definitions.ContestPaymentDisputeRequest] = None, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], ContestPaymentDisputeResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.POST, host + basePath + "/payment_dispute/" + Formatter.addPath(paymentDisputeId) + "/contest", allHeaders, body, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.NoContent =>
        resp.discardEntityBytes().future.map(_ => Right(ContestPaymentDisputeResponse.NoContent))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(ContestPaymentDisputeResponse.BadRequest))
      case StatusCodes.NotFound =>
        resp.discardEntityBytes().future.map(_ => Right(ContestPaymentDisputeResponse.NotFound))
      case StatusCodes.Conflict =>
        resp.discardEntityBytes().future.map(_ => Right(ContestPaymentDisputeResponse.Conflict))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(ContestPaymentDisputeResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def fetchEvidenceContent(paymentDisputeId: String, evidenceId: String, fileId: String, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], FetchEvidenceContentResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.GET, host + basePath + "/payment_dispute/" + Formatter.addPath(paymentDisputeId) + "/fetch_evidence_content" + "?" + Formatter.addArg("evidence_id", evidenceId) + Formatter.addArg("file_id", fileId), allHeaders, HttpEntity.Empty, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.OK =>
        Unmarshal(resp.entity).to[Vector[String]](fetchEvidenceContentOKDecoder, implicitly, implicitly).map(x => Right(FetchEvidenceContentResponse.OK(x)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(FetchEvidenceContentResponse.BadRequest))
      case StatusCodes.NotFound =>
        resp.discardEntityBytes().future.map(_ => Right(FetchEvidenceContentResponse.NotFound))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(FetchEvidenceContentResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def updateEvidence(paymentDisputeId: String, body: Option[_root_.sell.fulfillment.definitions.UpdateEvidencePaymentDisputeRequest] = None, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], UpdateEvidenceResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.POST, host + basePath + "/payment_dispute/" + Formatter.addPath(paymentDisputeId) + "/update_evidence", allHeaders, body, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.NoContent =>
        resp.discardEntityBytes().future.map(_ => Right(UpdateEvidenceResponse.NoContent))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(UpdateEvidenceResponse.BadRequest))
      case StatusCodes.NotFound =>
        resp.discardEntityBytes().future.map(_ => Right(UpdateEvidenceResponse.NotFound))
      case StatusCodes.Conflict =>
        resp.discardEntityBytes().future.map(_ => Right(UpdateEvidenceResponse.Conflict))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(UpdateEvidenceResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def uploadEvidenceFile(paymentDisputeId: String, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], UploadEvidenceFileResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.POST, host + basePath + "/payment_dispute/" + Formatter.addPath(paymentDisputeId) + "/upload_evidence_file", allHeaders, HttpEntity.Empty, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.OK =>
        Unmarshal(resp.entity).to[_root_.sell.fulfillment.definitions.FileEvidence](uploadEvidenceFileOKDecoder, implicitly, implicitly).map(x => Right(UploadEvidenceFileResponse.OK(x)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(UploadEvidenceFileResponse.BadRequest))
      case StatusCodes.NotFound =>
        resp.discardEntityBytes().future.map(_ => Right(UploadEvidenceFileResponse.NotFound))
      case StatusCodes.Conflict =>
        resp.discardEntityBytes().future.map(_ => Right(UploadEvidenceFileResponse.Conflict))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(UploadEvidenceFileResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
  def getPaymentDisputeSummaries(orderId: Option[String] = None, buyerUsername: Option[String] = None, openDateFrom: Option[String] = None, openDateTo: Option[String] = None, paymentDisputeStatus: Option[String] = None, limit: Option[String] = None, offset: Option[String] = None, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], GetPaymentDisputeSummariesResponse] = {
    val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten
    makeRequest(HttpMethods.GET, host + basePath + "/payment_dispute_summary" + "?" + Formatter.addArg("order_id", orderId) + Formatter.addArg("buyer_username", buyerUsername) + Formatter.addArg("open_date_from", openDateFrom) + Formatter.addArg("open_date_to", openDateTo) + Formatter.addArg("payment_dispute_status", paymentDisputeStatus) + Formatter.addArg("limit", limit) + Formatter.addArg("offset", offset), allHeaders, HttpEntity.Empty, HttpProtocols.`HTTP/1.1`).flatMap(req => EitherT(httpClient(req).flatMap(resp => resp.status match {
      case StatusCodes.OK =>
        Unmarshal(resp.entity).to[_root_.sell.fulfillment.definitions.DisputeSummaryResponse](getPaymentDisputeSummariesOKDecoder, implicitly, implicitly).map(x => Right(GetPaymentDisputeSummariesResponse.OK(x)))
      case StatusCodes.BadRequest =>
        resp.discardEntityBytes().future.map(_ => Right(GetPaymentDisputeSummariesResponse.BadRequest))
      case StatusCodes.InternalServerError =>
        resp.discardEntityBytes().future.map(_ => Right(GetPaymentDisputeSummariesResponse.InternalServerError))
      case _ =>
        FastFuture.successful(Left(Right(resp)))
    }).recover({
      case e: Throwable =>
        Left(Left(e))
    })))
  }
}
sealed abstract class GetOrdersResponse {
  def fold[A](handleOK: _root_.sell.fulfillment.definitions.OrderSearchPagedCollection => A, handleBadRequest: => A, handleInternalServerError: => A): A = this match {
    case x: GetOrdersResponse.OK =>
      handleOK(x.value)
    case GetOrdersResponse.BadRequest =>
      handleBadRequest
    case GetOrdersResponse.InternalServerError =>
      handleInternalServerError
  }
}
object GetOrdersResponse {
  case class OK(value: _root_.sell.fulfillment.definitions.OrderSearchPagedCollection) extends GetOrdersResponse
  case object BadRequest extends GetOrdersResponse
  case object InternalServerError extends GetOrdersResponse
}
sealed abstract class GetOrderResponse {
  def fold[A](handleOK: _root_.sell.fulfillment.definitions.Order => A, handleBadRequest: => A, handleNotFound: => A, handleInternalServerError: => A): A = this match {
    case x: GetOrderResponse.OK =>
      handleOK(x.value)
    case GetOrderResponse.BadRequest =>
      handleBadRequest
    case GetOrderResponse.NotFound =>
      handleNotFound
    case GetOrderResponse.InternalServerError =>
      handleInternalServerError
  }
}
object GetOrderResponse {
  case class OK(value: _root_.sell.fulfillment.definitions.Order) extends GetOrderResponse
  case object BadRequest extends GetOrderResponse
  case object NotFound extends GetOrderResponse
  case object InternalServerError extends GetOrderResponse
}
sealed abstract class CreateShippingFulfillmentResponse {
  def fold[A](handleCreated: (io.circe.Json, Option[String]) => A, handleBadRequest: => A, handleInternalServerError: => A): A = this match {
    case x: CreateShippingFulfillmentResponse.Created =>
      handleCreated(x.value, x.locationHeader)
    case CreateShippingFulfillmentResponse.BadRequest =>
      handleBadRequest
    case CreateShippingFulfillmentResponse.InternalServerError =>
      handleInternalServerError
  }
}
object CreateShippingFulfillmentResponse {
  case class Created(value: io.circe.Json, locationHeader: Option[String]) extends CreateShippingFulfillmentResponse
  case object BadRequest extends CreateShippingFulfillmentResponse
  case object InternalServerError extends CreateShippingFulfillmentResponse
}
sealed abstract class GetShippingFulfillmentsResponse {
  def fold[A](handleOK: _root_.sell.fulfillment.definitions.ShippingFulfillmentPagedCollection => A, handleBadRequest: => A, handleInternalServerError: => A): A = this match {
    case x: GetShippingFulfillmentsResponse.OK =>
      handleOK(x.value)
    case GetShippingFulfillmentsResponse.BadRequest =>
      handleBadRequest
    case GetShippingFulfillmentsResponse.InternalServerError =>
      handleInternalServerError
  }
}
object GetShippingFulfillmentsResponse {
  case class OK(value: _root_.sell.fulfillment.definitions.ShippingFulfillmentPagedCollection) extends GetShippingFulfillmentsResponse
  case object BadRequest extends GetShippingFulfillmentsResponse
  case object InternalServerError extends GetShippingFulfillmentsResponse
}
sealed abstract class GetShippingFulfillmentResponse {
  def fold[A](handleOK: _root_.sell.fulfillment.definitions.ShippingFulfillment => A, handleBadRequest: => A, handleNotFound: => A, handleInternalServerError: => A): A = this match {
    case x: GetShippingFulfillmentResponse.OK =>
      handleOK(x.value)
    case GetShippingFulfillmentResponse.BadRequest =>
      handleBadRequest
    case GetShippingFulfillmentResponse.NotFound =>
      handleNotFound
    case GetShippingFulfillmentResponse.InternalServerError =>
      handleInternalServerError
  }
}
object GetShippingFulfillmentResponse {
  case class OK(value: _root_.sell.fulfillment.definitions.ShippingFulfillment) extends GetShippingFulfillmentResponse
  case object BadRequest extends GetShippingFulfillmentResponse
  case object NotFound extends GetShippingFulfillmentResponse
  case object InternalServerError extends GetShippingFulfillmentResponse
}
sealed abstract class IssueRefundResponse {
  def fold[A](handleOK: _root_.sell.fulfillment.definitions.Refund => A, handleBadRequest: => A, handleForbidden: => A, handleNotFound: => A, handleConflict: => A, handleInternalServerError: => A): A = this match {
    case x: IssueRefundResponse.OK =>
      handleOK(x.value)
    case IssueRefundResponse.BadRequest =>
      handleBadRequest
    case IssueRefundResponse.Forbidden =>
      handleForbidden
    case IssueRefundResponse.NotFound =>
      handleNotFound
    case IssueRefundResponse.Conflict =>
      handleConflict
    case IssueRefundResponse.InternalServerError =>
      handleInternalServerError
  }
}
object IssueRefundResponse {
  case class OK(value: _root_.sell.fulfillment.definitions.Refund) extends IssueRefundResponse
  case object BadRequest extends IssueRefundResponse
  case object Forbidden extends IssueRefundResponse
  case object NotFound extends IssueRefundResponse
  case object Conflict extends IssueRefundResponse
  case object InternalServerError extends IssueRefundResponse
}
sealed abstract class GetPaymentDisputeResponse {
  def fold[A](handleOK: _root_.sell.fulfillment.definitions.PaymentDispute => A, handleBadRequest: => A, handleNotFound: => A, handleInternalServerError: => A): A = this match {
    case x: GetPaymentDisputeResponse.OK =>
      handleOK(x.value)
    case GetPaymentDisputeResponse.BadRequest =>
      handleBadRequest
    case GetPaymentDisputeResponse.NotFound =>
      handleNotFound
    case GetPaymentDisputeResponse.InternalServerError =>
      handleInternalServerError
  }
}
object GetPaymentDisputeResponse {
  case class OK(value: _root_.sell.fulfillment.definitions.PaymentDispute) extends GetPaymentDisputeResponse
  case object BadRequest extends GetPaymentDisputeResponse
  case object NotFound extends GetPaymentDisputeResponse
  case object InternalServerError extends GetPaymentDisputeResponse
}
sealed abstract class AcceptPaymentDisputeResponse {
  def fold[A](handleNoContent: => A, handleBadRequest: => A, handleNotFound: => A, handleConflict: => A, handleInternalServerError: => A): A = this match {
    case AcceptPaymentDisputeResponse.NoContent => handleNoContent
    case AcceptPaymentDisputeResponse.BadRequest => handleBadRequest
    case AcceptPaymentDisputeResponse.NotFound => handleNotFound
    case AcceptPaymentDisputeResponse.Conflict => handleConflict
    case AcceptPaymentDisputeResponse.InternalServerError => handleInternalServerError
  }
}
object AcceptPaymentDisputeResponse {
  case object NoContent extends AcceptPaymentDisputeResponse
  case object BadRequest extends AcceptPaymentDisputeResponse
  case object NotFound extends AcceptPaymentDisputeResponse
  case object Conflict extends AcceptPaymentDisputeResponse
  case object InternalServerError extends AcceptPaymentDisputeResponse
}
sealed abstract class GetActivitiesResponse {
  def fold[A](handleOK: _root_.sell.fulfillment.definitions.PaymentDisputeActivityHistory => A, handleBadRequest: => A, handleNotFound: => A, handleInternalServerError: => A): A = this match {
    case x: GetActivitiesResponse.OK =>
      handleOK(x.value)
    case GetActivitiesResponse.BadRequest =>
      handleBadRequest
    case GetActivitiesResponse.NotFound =>
      handleNotFound
    case GetActivitiesResponse.InternalServerError =>
      handleInternalServerError
  }
}
object GetActivitiesResponse {
  case class OK(value: _root_.sell.fulfillment.definitions.PaymentDisputeActivityHistory) extends GetActivitiesResponse
  case object BadRequest extends GetActivitiesResponse
  case object NotFound extends GetActivitiesResponse
  case object InternalServerError extends GetActivitiesResponse
}
sealed abstract class AddEvidenceResponse {
  def fold[A](handleOK: _root_.sell.fulfillment.definitions.AddEvidencePaymentDisputeResponse => A, handleBadRequest: => A, handleNotFound: => A, handleConflict: => A, handleInternalServerError: => A): A = this match {
    case x: AddEvidenceResponse.OK =>
      handleOK(x.value)
    case AddEvidenceResponse.BadRequest =>
      handleBadRequest
    case AddEvidenceResponse.NotFound =>
      handleNotFound
    case AddEvidenceResponse.Conflict =>
      handleConflict
    case AddEvidenceResponse.InternalServerError =>
      handleInternalServerError
  }
}
object AddEvidenceResponse {
  case class OK(value: _root_.sell.fulfillment.definitions.AddEvidencePaymentDisputeResponse) extends AddEvidenceResponse
  case object BadRequest extends AddEvidenceResponse
  case object NotFound extends AddEvidenceResponse
  case object Conflict extends AddEvidenceResponse
  case object InternalServerError extends AddEvidenceResponse
}
sealed abstract class ContestPaymentDisputeResponse {
  def fold[A](handleNoContent: => A, handleBadRequest: => A, handleNotFound: => A, handleConflict: => A, handleInternalServerError: => A): A = this match {
    case ContestPaymentDisputeResponse.NoContent => handleNoContent
    case ContestPaymentDisputeResponse.BadRequest => handleBadRequest
    case ContestPaymentDisputeResponse.NotFound => handleNotFound
    case ContestPaymentDisputeResponse.Conflict => handleConflict
    case ContestPaymentDisputeResponse.InternalServerError => handleInternalServerError
  }
}
object ContestPaymentDisputeResponse {
  case object NoContent extends ContestPaymentDisputeResponse
  case object BadRequest extends ContestPaymentDisputeResponse
  case object NotFound extends ContestPaymentDisputeResponse
  case object Conflict extends ContestPaymentDisputeResponse
  case object InternalServerError extends ContestPaymentDisputeResponse
}
sealed abstract class FetchEvidenceContentResponse {
  def fold[A](handleOK: Vector[String] => A, handleBadRequest: => A, handleNotFound: => A, handleInternalServerError: => A): A = this match {
    case x: FetchEvidenceContentResponse.OK =>
      handleOK(x.value)
    case FetchEvidenceContentResponse.BadRequest =>
      handleBadRequest
    case FetchEvidenceContentResponse.NotFound =>
      handleNotFound
    case FetchEvidenceContentResponse.InternalServerError =>
      handleInternalServerError
  }
}
object FetchEvidenceContentResponse {
  case class OK(value: Vector[String]) extends FetchEvidenceContentResponse
  case object BadRequest extends FetchEvidenceContentResponse
  case object NotFound extends FetchEvidenceContentResponse
  case object InternalServerError extends FetchEvidenceContentResponse
}
sealed abstract class UpdateEvidenceResponse {
  def fold[A](handleNoContent: => A, handleBadRequest: => A, handleNotFound: => A, handleConflict: => A, handleInternalServerError: => A): A = this match {
    case UpdateEvidenceResponse.NoContent => handleNoContent
    case UpdateEvidenceResponse.BadRequest => handleBadRequest
    case UpdateEvidenceResponse.NotFound => handleNotFound
    case UpdateEvidenceResponse.Conflict => handleConflict
    case UpdateEvidenceResponse.InternalServerError => handleInternalServerError
  }
}
object UpdateEvidenceResponse {
  case object NoContent extends UpdateEvidenceResponse
  case object BadRequest extends UpdateEvidenceResponse
  case object NotFound extends UpdateEvidenceResponse
  case object Conflict extends UpdateEvidenceResponse
  case object InternalServerError extends UpdateEvidenceResponse
}
sealed abstract class UploadEvidenceFileResponse {
  def fold[A](handleOK: _root_.sell.fulfillment.definitions.FileEvidence => A, handleBadRequest: => A, handleNotFound: => A, handleConflict: => A, handleInternalServerError: => A): A = this match {
    case x: UploadEvidenceFileResponse.OK =>
      handleOK(x.value)
    case UploadEvidenceFileResponse.BadRequest =>
      handleBadRequest
    case UploadEvidenceFileResponse.NotFound =>
      handleNotFound
    case UploadEvidenceFileResponse.Conflict =>
      handleConflict
    case UploadEvidenceFileResponse.InternalServerError =>
      handleInternalServerError
  }
}
object UploadEvidenceFileResponse {
  case class OK(value: _root_.sell.fulfillment.definitions.FileEvidence) extends UploadEvidenceFileResponse
  case object BadRequest extends UploadEvidenceFileResponse
  case object NotFound extends UploadEvidenceFileResponse
  case object Conflict extends UploadEvidenceFileResponse
  case object InternalServerError extends UploadEvidenceFileResponse
}
sealed abstract class GetPaymentDisputeSummariesResponse {
  def fold[A](handleOK: _root_.sell.fulfillment.definitions.DisputeSummaryResponse => A, handleBadRequest: => A, handleInternalServerError: => A): A = this match {
    case x: GetPaymentDisputeSummariesResponse.OK =>
      handleOK(x.value)
    case GetPaymentDisputeSummariesResponse.BadRequest =>
      handleBadRequest
    case GetPaymentDisputeSummariesResponse.InternalServerError =>
      handleInternalServerError
  }
}
object GetPaymentDisputeSummariesResponse {
  case class OK(value: _root_.sell.fulfillment.definitions.DisputeSummaryResponse) extends GetPaymentDisputeSummariesResponse
  case object BadRequest extends GetPaymentDisputeSummariesResponse
  case object InternalServerError extends GetPaymentDisputeSummariesResponse
}