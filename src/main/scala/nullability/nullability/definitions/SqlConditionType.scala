/*
 * This file was generated by Guardrail (https://github.com/twilio/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package nullability.definitions
import _root_.nullability.Implicits._
import cats.syntax.either._
import io.circe._
import io.circe.syntax._
import io.circe.generic.semiauto._
import cats.implicits._
sealed abstract class SqlConditionType(val value: String) { override def toString: String = value.toString }
object SqlConditionType {
  object members {
    case object And extends SqlConditionType("AND")
    case object Or extends SqlConditionType("OR")
    case object Not extends SqlConditionType("NOT")
  }
  val And: SqlConditionType = members.And
  val Or: SqlConditionType = members.Or
  val Not: SqlConditionType = members.Not
  val values = Vector(And, Or, Not)
  implicit val encodeSqlConditionType: Encoder[SqlConditionType] = Encoder[String].contramap(_.value)
  implicit val decodeSqlConditionType: Decoder[SqlConditionType] = Decoder[String].emap(value => parse(value).toRight(s"$value not a member of SqlConditionType"))
  implicit val addPathSqlConditionType: AddPath[SqlConditionType] = AddPath.build(_.value)
  implicit val showSqlConditionType: Show[SqlConditionType] = Show.build(_.value)
  def parse(value: String): Option[SqlConditionType] = values.find(_.value == value)
  implicit val order: cats.Order[SqlConditionType] = cats.Order.by[SqlConditionType, Int](values.indexOf)
}