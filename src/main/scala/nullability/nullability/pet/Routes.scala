/*
 * This file was generated by Guardrail (https://github.com/twilio/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package nullability.pet
import akka.http.scaladsl.model._
import akka.http.scaladsl.model.headers.RawHeader
import akka.http.scaladsl.unmarshalling.{ Unmarshal, Unmarshaller, FromEntityUnmarshaller, FromRequestUnmarshaller, FromStringUnmarshaller }
import akka.http.scaladsl.marshalling.{ Marshal, Marshaller, Marshalling, ToEntityMarshaller, ToResponseMarshaller }
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.server.{ Directive, Directive0, Directive1, ExceptionHandler, MalformedFormFieldRejection, MalformedHeaderRejection, MissingFormFieldRejection, MalformedRequestContentRejection, Rejection, RejectionError, Route }
import akka.http.scaladsl.util.FastFuture
import akka.stream.{ IOResult, Materializer }
import akka.stream.scaladsl.{ FileIO, Keep, Sink, Source }
import akka.util.ByteString
import io.circe.Decoder
import cats.{ Functor, Id }
import cats.data.EitherT
import cats.implicits._
import scala.concurrent.{ ExecutionContext, Future }
import scala.language.higherKinds
import scala.language.implicitConversions
import java.io.File
import java.security.MessageDigest
import java.util.concurrent.atomic.AtomicReference
import scala.util.{ Failure, Success }
import scala.language.higherKinds
import _root_.nullability.Implicits._
import _root_.nullability.AkkaHttpImplicits._
import _root_.nullability.definitions._
trait PetHandler {
  def updatePet(respond: PetResource.updatePetResponse.type)(name: String, body: Option[_root_.nullability.definitions.Pet] = None): scala.concurrent.Future[PetResource.updatePetResponse]
  def createPet(respond: PetResource.createPetResponse.type)(name: Option[String] = None, status: Option[String] = None, file: Option[(File, Option[String], ContentType)] = None): scala.concurrent.Future[PetResource.createPetResponse]
  def createPetMapFileField(fieldName: String, fileName: Option[String], contentType: ContentType): File
  def createPetUnmarshalToFile[F[_]: Functor](hashType: F[String], destFn: (String, Option[String], ContentType) => File)(implicit mat: Materializer): Unmarshaller[Multipart.FormData.BodyPart, (File, Option[String], ContentType, F[String])] = Unmarshaller { implicit executionContext => 
    part => {
      val dest = destFn(part.name, part.filename, part.entity.contentType)
      val messageDigest = hashType.map(MessageDigest.getInstance(_))
      val fileSink: Sink[ByteString, Future[IOResult]] = FileIO.toPath(dest.toPath).contramap[ByteString] { chunk => 
        val _ = messageDigest.map(_.update(chunk.toArray[Byte]))
        chunk
      }
      part.entity.dataBytes.toMat(fileSink)(Keep.right).run().transform({
        case IOResult(_, Success(_)) =>
          val hash = messageDigest.map(md => javax.xml.bind.DatatypeConverter.printHexBinary(md.digest()).toLowerCase(java.util.Locale.US))
          (dest, part.filename, part.entity.contentType, hash)
        case IOResult(_, Failure(t)) =>
          dest.delete()
          throw t
      }, {
        case t =>
          dest.delete()
          t
      })
    }
  }
}
object PetResource {
  val updatePetDecoder: FromRequestUnmarshaller[_root_.nullability.definitions.Pet] = {
    val extractEntity = implicitly[Unmarshaller[HttpMessage, HttpEntity]]
    val unmarshalEntity = {
      structuredJsonEntityUnmarshaller.flatMap(_ => _ => json => io.circe.Decoder[_root_.nullability.definitions.Pet].decodeJson(json).fold(FastFuture.failed, FastFuture.successful))
    }
    extractEntity.andThen(unmarshalEntity)
  }
  def routes(handler: PetHandler)(implicit mat: akka.stream.Materializer): Route = {
    {
      put(path("v1" / "pet" / Segment).apply(name => entity(as[Option[_root_.nullability.definitions.Pet]](updatePetDecoder)).apply(body => complete(handler.updatePet(updatePetResponse)(name, body)))))
    } ~ ({
      post(path("v1" / "pets")(({
        object createPetParts {
          sealed trait Part
          case class IgnoredPart(unit: Unit) extends Part
          case class name(value: String) extends Part
          case class status(value: String) extends Part
          case class file(value: (File, Option[String], ContentType)) extends Part
        }
        val UnmarshalnamePart: Unmarshaller[Multipart.FormData.BodyPart, createPetParts.name] = Unmarshaller { implicit executionContext => 
          part => Unmarshaller.firstOf(MFDBPviaFSU(stringyJsonEntityUnmarshaller.andThen(unmarshallJson[String])), MFDBPviaFSU(structuredJsonEntityUnmarshaller.andThen(unmarshallJson[String]))).apply(part).map(createPetParts.name.apply).recoverWith({
            case ex =>
              Future.failed(RejectionError(MalformedFormFieldRejection(part.name, ex.getMessage, Some(ex))))
          })
        }
        val UnmarshalstatusPart: Unmarshaller[Multipart.FormData.BodyPart, createPetParts.status] = Unmarshaller { implicit executionContext => 
          part => Unmarshaller.firstOf(MFDBPviaFSU(stringyJsonEntityUnmarshaller.andThen(unmarshallJson[String])), MFDBPviaFSU(structuredJsonEntityUnmarshaller.andThen(unmarshallJson[String]))).apply(part).map(createPetParts.status.apply).recoverWith({
            case ex =>
              Future.failed(RejectionError(MalformedFormFieldRejection(part.name, ex.getMessage, Some(ex))))
          })
        }
        val UnmarshalfilePart: Unmarshaller[Multipart.FormData.BodyPart, createPetParts.file] = handler.createPetUnmarshalToFile[Option](None, handler.createPetMapFileField(_, _, _)).map({
          case (v1, v2, v3, v4) =>
            createPetParts.file((v1, v2, v3))
        })
        val fileReferences = new AtomicReference(List.empty[File])
        implicit val MultipartFormDataUnmarshaller: FromRequestUnmarshaller[Either[Throwable, (Option[String], Option[String], Option[(File, Option[String], ContentType)])]] = implicitly[FromRequestUnmarshaller[Multipart.FormData]].flatMap { implicit executionContext => 
          implicit mat => { formData => 
            val collectedPartsF: Future[Either[Throwable, (Option[String], Option[String], Option[(File, Option[String], ContentType)])]] = for (results <- formData.parts.mapConcat {
              part => if (Set[String]("name", "status", "file").contains(part.name)) part :: Nil else {
                part.entity.discardBytes()
                Nil
              }
            }.mapAsync(1) {
              part => part.name match {
                case "name" =>
                  SafeUnmarshaller(UnmarshalnamePart).apply(part)
                case "status" =>
                  SafeUnmarshaller(UnmarshalstatusPart).apply(part)
                case "file" =>
                  SafeUnmarshaller(AccumulatingUnmarshaller(fileReferences, UnmarshalfilePart)(_.value._1)).apply(part)
                case _ =>
                  SafeUnmarshaller(implicitly[Unmarshaller[Multipart.FormData.BodyPart, Unit]].map(createPetParts.IgnoredPart.apply(_))).apply(part)
              }
            }.toMat(Sink.seq[Either[Throwable, createPetParts.Part]])(Keep.right).run()) yield {
              results.toList.sequence.map { successes => 
                val nameO = successes.collectFirst({
                  case createPetParts.name(v1) => v1
                })
                val statusO = successes.collectFirst({
                  case createPetParts.status(v1) => v1
                })
                val fileO = successes.collectFirst({
                  case createPetParts.file((v1, v2, v3)) =>
                    (v1, v2, v3)
                })
                (nameO, statusO, fileO)
              }
            }
            collectedPartsF
          }
        }
        (handleExceptions(ExceptionHandler({
          case e: Throwable =>
            fileReferences.get().foreach(_.delete())
            throw e
        })) & extractSettings.flatMap {
          settings => handleRejections { (rejections: scala.collection.immutable.Seq[Rejection]) => 
            fileReferences.get().foreach(_.delete())
            rejections.collectFirst({
              case MalformedRequestContentRejection(msg, EntityStreamSizeException(limit, contentLength)) =>
                val summary = contentLength match {
                  case Some(cl) =>
                    s"Request Content-Length of $cl bytes exceeds the configured limit of $limit bytes"
                  case None =>
                    s"Aggregated data length of request entity exceeds the configured limit of $limit bytes"
                }
                val info = new ErrorInfo(summary, "Consider increasing the value of akka.http.server.parsing.max-content-length")
                val status = StatusCodes.RequestEntityTooLarge
                val msg = if (settings.verboseErrorMessages) info.formatPretty else info.summary
                complete(HttpResponse(status, entity = msg))
            })
          }
        } & mapResponse { resp => 
          fileReferences.get().foreach(_.delete())
          resp
        } & entity(as(Unmarshaller.firstOf(MultipartFormDataUnmarshaller)))).flatMap(_.fold({
          case RejectionError(rej) =>
            reject(rej)
          case t =>
            throw t
        }, {
          case (nameO, statusO, fileO) =>
            val maybe: Either[Rejection, (Option[String], Option[String], Option[(File, Option[String], ContentType)])] = for (name <- Either.right[MissingFormFieldRejection, Option[String]](nameO); status <- Either.right[MissingFormFieldRejection, Option[String]](statusO); file <- Either.right[MissingFormFieldRejection, Option[(File, Option[String], ContentType)]](fileO)) yield {
              (name, status, file)
            }
            maybe.fold(reject(_), tprovide(_))
        }))
      }: Directive[(Option[String], Option[String], Option[(File, Option[String], ContentType)])]).apply((name, status, file) => complete(handler.createPet(createPetResponse)(name, status, file)))))
    })
  }
  sealed abstract class updatePetResponse(val statusCode: StatusCode)
  case class updatePetResponseOK(value: _root_.nullability.definitions.Pet) extends updatePetResponse(StatusCodes.OK)
  object updatePetResponse {
    implicit val updatePetTRM: ToResponseMarshaller[updatePetResponse] = Marshaller { implicit ec => 
      resp => updatePetTR(resp)
    }
    implicit def updatePetTR(value: updatePetResponse)(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[List[Marshalling[HttpResponse]]] = value match {
      case r @ updatePetResponseOK(value) =>
        Marshal(value).to[ResponseEntity].map {
          entity => Marshalling.Opaque {
            () => HttpResponse(r.statusCode, entity = entity)
          } :: Nil
        }
    }
    def apply[T](value: T)(implicit ev: T => updatePetResponse): updatePetResponse = ev(value)
    implicit def OKEv(value: _root_.nullability.definitions.Pet): updatePetResponse = OK(value)
    def OK(value: _root_.nullability.definitions.Pet): updatePetResponse = updatePetResponseOK(value)
  }
  sealed abstract class createPetResponse(val statusCode: StatusCode)
  case class createPetResponseOK(value: _root_.nullability.definitions.Pet) extends createPetResponse(StatusCodes.OK)
  object createPetResponse {
    implicit val createPetTRM: ToResponseMarshaller[createPetResponse] = Marshaller { implicit ec => 
      resp => createPetTR(resp)
    }
    implicit def createPetTR(value: createPetResponse)(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[List[Marshalling[HttpResponse]]] = value match {
      case r @ createPetResponseOK(value) =>
        Marshal(value).to[ResponseEntity].map {
          entity => Marshalling.Opaque {
            () => HttpResponse(r.statusCode, entity = entity)
          } :: Nil
        }
    }
    def apply[T](value: T)(implicit ev: T => createPetResponse): createPetResponse = ev(value)
    implicit def OKEv(value: _root_.nullability.definitions.Pet): createPetResponse = OK(value)
    def OK(value: _root_.nullability.definitions.Pet): createPetResponse = createPetResponseOK(value)
  }
}